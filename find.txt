


-- to_pip.py
import argparse
import os
import shutil
import sys
import tempfile


def usage():
    print(
        f"Usage: python -m to_pip -n <package_name> -v <package_version> [-u <pypi_username> -p <pypi_password>] <python_files>"
    )
    sys.exit(1)


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("-n", "--package_name", help="Package name", required=True)
    parser.add_argument("-v", "--package_version", help="Package version", required=True)
    parser.add_argument("-u", "--pypi_username", help="PyPI username", default="")
    parser.add_argument("-p", "--pypi_password", help="PyPI password", default="")
    parser.add_argument("python_files", nargs="*", help="Python files to include")
    return parser.parse_args()


def to_pip():
    args = parse_args()

    if not args.python_files:
        usage()

    tmp_dir = tempfile.mkdtemp()
    package_dir = os.path.join(tmp_dir, f"{args.package_name}-{args.package_version}")
    os.makedirs(package_dir)

    for file in args.python_files:
        with open(file) as src, open(
                os.path.join(package_dir, os.path.basename(file)), "w"
        ) as dest:
            dest.write("#!/usr/bin/env python\n")
            dest.write(src.read())
        os.system(f"chmod +x {os.path.join(package_dir, os.path.basename(file))}")

    if os.path.exists("requirements.txt"):
        shutil.copy("requirements.txt", os.path.join(package_dir, "requirements.txt"))

    modules = ", ".join([f"'{os.path.basename(file).split('.')[0].replace('-', '_')}'" for file in args.python_files])
    entry_points = ", ".join(
        [
            f"{os.path.basename(file).split('.')[0].replace('-', '_')} = {os.path.basename(file).split('.')[0].replace('-', '_')}:main"
            for file in args.python_files
        ]
    )

    setup_py = f"""
from setuptools import setup, find_packages

with open('requirements.txt') as f:
    requirements = [line.strip() for line in f.readlines()]

setup(
    name="{args.package_name}",
    version="{args.package_version}",
    packages=find_packages(),
    py_modules=[{modules}],
    install_requires=requirements,
    entry_points={{
        'console_scripts': [
            '{entry_points}',
        ],
    }},
    long_description=open('README.md', 'r').read(),
    long_description_content_type='text/markdown',)
"""

    with open(os.path.join(package_dir, "setup.py"), "w") as f:
        f.write(setup_py)

    if os.path.exists("README.md"):
        shutil.copy("README.md", os.path.join(package_dir, "README.md"))

    os.system(f"cd {package_dir} && python setup.py sdist bdist_wheel")

    if args.pypi_username and args.pipy_password:
        pypirc_content = f"""
[distutils]
index-servers =
  pypi

[pypi]
repository: https://upload.pypi.org/legacy/
username: {args.pipy_username}
password: {args.pipy_password}
"""
        with open(os.path.expanduser("~/.pypirc"), "w") as f:
            f.write(pypirc_content)

    os.system(f"cd {package_dir} && twine upload dist/*")


def main():
    to_pip()


if __name__ == "__main__":
    main()


-- find.sh
pwd
find . -type f \( -name "*.js" -o -name "*.html" -o -name "*.py" -o -name "*.sh" \) -not -path "./venv/*" -exec sh -c 'echo "\n\n" && echo -- "${0##*/}" && cat "${0}"' {} \; > find.txt
echo output find.txt


-- uv.sh
uvicorn app:app --reload



-- push.sh
git add .
git commit -m ok
git push



-- to_pip.sh
#!/bin/bash

# Function to display usage
usage() {
  echo "Usage: $0 -n <package_name> -v <package_version> [-u <pypi_username> -p <pypi_password>] <python_files>"
  exit 1
}

# Check if any arguments are provided
if [ $# -eq 0 ]; then
  usage
fi

# Parse command line arguments
while getopts "n:v:u:p:" opt; do
  case $opt in
    n) name="$OPTARG" ;;
    v) version="$OPTARG" ;;
    u) username="$OPTARG" ;;
    p) password="$OPTARG" ;;
    *) usage ;;
  esac
done

# Remove parsed options
shift $((OPTIND-1))

# Check if package name and version are provided
if [ -z "$name" ] || [ -z "$version" ]; then
  usage
fi

# Create temporary directory and copy Python files
tmp_dir=$(mktemp -d)
package_dir="${tmp_dir}/${name}-${version}"
mkdir -p "$package_dir"
for file in "$@"; do
  # Add shebang line to the Python file
  echo "#!/usr/bin/env python" > "${package_dir}/$(basename "$file")"
  cat "$file" >> "${package_dir}/$(basename "$file")"
  chmod +x "${package_dir}/$(basename "$file")"
done

# Add requirements.txt if it exists
if [ -f ./requirements.txt ]; then
  cat ./requirements.txt > "${package_dir}/requirements.txt"
fi

# Create setup.py file
modules=""
entry_points=""
for file in "$@"; do
  base_name=$(basename -s .py "$file" | tr '-' '_')
  modules="${modules}, '${base_name}'"
  entry_points="${entry_points}${base_name} = ${base_name}:main,"
done
modules=${modules#,}
entry_points=${entry_points%,}

cat > "${package_dir}/setup.py" << EOF
from setuptools import setup, find_packages

# Read requirements.txt
with open('requirements.txt') as f:
    requirements = [line.strip() for line in f.readlines()]

setup(
    name="${name}",
    version="${version}",
    packages=find_packages(),
    py_modules=[${modules}],
    install_requires=requirements,
    entry_points={
        'console_scripts': [
            '${entry_points}',
        ],
    },
    long_description=open('README.md', 'r').read(),
    long_description_content_type='text/markdown',)
EOF

# Copy README.md to project description
if [ -f ./README.md ]; then
  cat ./README.md > "${package_dir}/README.md"
fi

# Build the package
cd "$package_dir"
python setup.py sdist bdist_wheel

# Configure PyPI credentials if provided
if [ ! -z "$username" ] && [ ! -z "$password" ]; then
  cat > ~/.pypirc << EOF
[distutils]
index-servers =
  pypi

[pypi]
repository: https://upload.pypi.org/legacy/
username: ${username}
password: ${password}
EOF
fi

# Upload the package to PyPI
twine upload dist/*



-- index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>
<body class="bg-dark text-white">
</body>
</html>


-- app.py
from fastapi import FastAPI, Request
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
from starlette.responses import RedirectResponse

app = FastAPI()
app.mount("/static", StaticFiles(directory="static"), name="static")


@app.get("/", response_class=HTMLResponse)
async def read_root(request: Request):
    return RedirectResponse("./static/html/index.html")
